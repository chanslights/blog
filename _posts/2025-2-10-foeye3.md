---
layout: post
title: "Foeye:  Cyberspace security detection system"
date: 2025-2-10 15:30:00 +0800
categories: [foeye]
tags: [internalship, foeye]
---
# Foeye3相关问题

技术特点:Gin + GORM + Database(MySQL+Redis+ElasticSearch) + JWT

# 一、Foeye项目目录解析

| 目录名 | 功能描述 |
| --- | --- |
| api | 包含各种功能模块的API处理器 |
| cmd | 命令行工具 |
| config | 配置相关 |
| crons | 定时任务，自动化任务的定时器。如备份、监控、风险检查等 |
| database | 数据库层，数据库模型定义，数据库操作接口，各种业务表的数据库操作实现 |
| middleware | 中间件层，HTTP请求处理中间件。例如认证、日志等通用功能 |
| model | 数据模型，业务数据结构定义，数据模型之间的关系。 |
| packages | 通用工具包，各种功能性的工具包。如加密、日志、网络等工具 |
| response | 响应定义。API响应结构定义，统一的响应格式 |
| server | 服务器核心。服务器的启动和配置，核心服务逻辑 |
| service | 业务服务层。具体业务代码，各模块的服务层代码 |
| store | 存储层。数据存储接口，不同存储的实现（Redis、MySQL） |
| etc | 配置文件目录。存放各种配置文件，如日志系统、系统配置等 |
| docs | 文档目录，API文档，使用说明文档 |
| test | 测试用例与测试工具 |
| internals | 内部实现，核心业务逻辑的内部实现代码 |

**Foeye项目架构图**
```
├── API层 (Gin框架)
├── 业务服务层 (Service)  
├── 数据访问层 (Database/Store)
└── 基础设施层 (Config/Middleware/Packages)
```

# 二、Foeye启动/工作流程

**Foeye启动流程**
```
1. 初始化配置 → 2. 连接数据库 → 3. 启动Gin引擎 → 4. 注册路由 → 5. 启动服务
```

## Facade Pattern 门面模式

**定义：**门面模式通过一个“门面”类，封装了多个子系统的细节，减少了客户端与子系统之间的依赖。它为客户端提供一个简单的接口，使得客户端无需关心系统内部的复杂逻辑和模块，只需要与门面接口交互即可。

**特点：**

*   **简化接口：**将多个子系统的复杂接口统一成一个简单的接口，客户端只需要与这个简单的接口交互
    
*   **解耦：**门面模式通过将客户端和子系统之间的依赖关系减少到最小，降低了系统的耦合度
    
*   **统一访问入口：**门面模式为客户端提供了一个统一的访问入口，客户端通过这个入口来与复杂系统进行交互，而不需要了解系统的具体实现
    

**使用门面模式的代码：**
```go
engine := gin.New()
engine.Use(common...)
ge := ar_engine.NewGinEngine()
ge.SetConfigure(configure)
ge.SetEngine(engine)
ge.SetDatabase(db)
ar_module.NewSwaggerRouter(ge).RouterRegister()
ar_module.NewUserRouter(ge).RouterRegister()
```

**不使用门面模式的代码：**
```go
ar_module.NewSwaggerRouter(engine,configure,db).RouterRegister()
ar_module.NewUserRouter(engine,configure,db).RouterRegister()
```

**对比：**

*   **不使用门面模式，**代码冗余和复杂性增加。
    
*   不使用门面模式，**参数顺序敏感** ：如果某个路由模块的构造函数参数顺序与其他模块不同，容易导致错误；**参数变更困难 ：**如果需要添加新的依赖，需要修改所有路由模块的构造函数和调用处容易出错 ；手动传递大量参数容易出现遗漏或顺序错误
    
*   不使用依赖模式，**耦合度增加**；**测试难度增加**，因为需要模拟更多的依赖
    
*   不使用门面模式：**添加新的路由模块时，需要复制大量重复代码**；修改依赖结构时，**需要修改所有路由模块的调用处**；代码**重构难度增加**
    

## 工厂模式

## WebSocket

**定义：**WebSocket是一种网络协议，它支持客户端与服务端之间长连接、双向连接，实现客户端和服务端之间的实时、低延迟效果。与传统的HTTP相比，WebSocket可以在客户之间维持一个长连接，允许数据实时双向传输。

**工作原理：**

*   **HandShake：**从一个标准的HTTP请求开始。然后客户端向服务器发送一个特殊的请求，要求将协议从HTTP升级为WebSocket协议，如果服务器返回101，则升级成功。
    
*   **数据传输：**建立成功之后，客户端和服务端之间就可以进行全双工通信。
    
*   **连接关闭：**客户端或服务器均可以主动关闭，需要发送一个关闭消息。
    

**特点：**

*   **全双工通信：**
    
*   **低延迟：**
    
*   **持久连接：**
    
*   **基于TCP：**WebSocket协议建立于TCP协议之上，可以实现数据的可靠传输。WebSocket协议的数据包比HTTP更小，效率更高
    

**应用场景：**

*   实时聊天应用
    
*   在线游戏
    
*   股票行情和金融交易
    
*   社交媒体通知
    
*   协作工具
    

## gRPC

**定义：**gRPC是基于HTTP/2协议进行高效通信的，支持多种语言并且提供了强类型的接口，能够简化跨语言的服务调用。

**工作原理：**

*   **定义服务：**使用Protocol Buffers定义服务接口和消息类型，在.proto文件中指定RPC方法和请求/响应类型
    
*   **编译.proto文件：**使用protoc编译器将.proto文件编译为客户端和服务器的代码，支持多种编译语言
    
*   **实现服务：**在服务端实现服务的具体逻辑，在客户端远程调用
    
*   **客户端和服务器通信：**客户端通过gRPC框架发起远程调用，服务器响应
    

**特点：**

*   **基于HTTP/2：**
    
    *   gRPC使用HTTP/2协议，相较于传统的HTTP/1.1，HTTP/2提供了更高的性能，支持流式传输、请求/响应多路复用、头压缩等
        
*   **接口定于语言（IDL）：**
    
    *   gRPC使用Protocol Buffers（protobuf）作为接口定义语言，只需要通过.proto文件来定义服务及其消息类型
        
*   **跨语言支持:**
    
*   **强类型的消息定义：**
    
    *   gRPC 使用 protobuf 进行强类型的消息定义，确保了客户端和服务端的数据一致性
        
*   **四种通信模型**
    
    *   **单向调用（Unary）：**客户端发起一个请求，服务端响应一个请求
        
    *   **服务器流式（Server Streaming）：**客户端发起一个请求，服务器返回一个流（多个响应）
        
    *   **客户端流式（Client Streaming）：**客户端发起一个流（多个响应），服务器返回一个响应
        
    *   **双向流式（Bidirectional Streaming）：**客户端和服务器都可以发送流，双方通过流的交互来交换数据
        
*   **内置支持认证和安全性**
    
    *   **支持TLS**
        

**应用场景：**

*   **微服务器架构：**
    
*   **高性能应用：**
    
*   **跨语言系统**
    
*   **loT：**
    

## Gorm

**定义：**

**工作原理：**

**特点：**

**适用场景：**

# 三、Foeye中如何实现IP在线状态展示并支持筛选的

**IP在线状态展示系统架构**
```
用户请求 → API接口 → ElasticSearch查询 → 数据过滤 → 返回结果
```

## 1.ElasticSearch

### 1.1 定义：

ElasticSearch就是即管理全文索引、复杂数据分析和分布式功能于一体的搜索引擎

### 1.2 基本数据结构：

**ElasticSearch数据结构层级关系**
```
Cluster 集群
  ├── Node 节点
  │   ├── Index 索引 (类似数据库)
  │   │   ├── Shard 分片
  │   │   │   ├── Segment 段文件
  │   │   │   └── Document 文档 (类似数据行)
  │   │   │       └── Field 字段
  │   │   └── Mapping 映射 (类似表结构)
  │   └── ...
  └── ...
```

**1.2.1 Index:**   

一个Index就是一个大的集合，类似于MySQL中的数据库。

举个例子，products这个Index下可以存放所有商品数据

**1.2.2 Shard:** 

一个Index被物理划分成多个Shard，每个Shard是一个完整的小型的、独立的Lucene索引。

举个例子，一个Index有5个主分片，每个主分片再配一个副本，就有10个Shard分布在集群节点

**1.2.3 Segment:** 

Shard内部有分为多个Segment组成，每个segement是一个标准的Lecene索引文件，Segment不可变。

举个例子，每当你不断插入数据时，ES在后台持续写新的Segment，后台有多个合并线程，不断把小Segment合并成大Segment。

**1.2.4 Type:** 

**1.2.5 Ducument:** 

一个Document相当于关系数据库中的一行Row，是最小的数据单位，每一个Document都是以JSON格式存储的。

举个例子，`{ "name": "Apple", "price": 3.5 }`  是一个Document，存放在`products`索引下。

**1.2.6 Field:** 

Document是由若干个Field字段组成的，每个Field都有自己的数据类型，比如text，keyword，integer，data等。

举个例子，Document中的name字段是text类型，price是float类型

**1.2.7 Mapping:** 

定义每个Filed的类型、分词方式、索引规则等，相当于关系数据库中的表结构

```json
{
  "name": "Apple iPhone 15",
  "price": 7999,
  "in_stock": true,
  "release_date": "2024-09-01"
}

PUT /products
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text",       // 支持全文搜索，比如模糊查找 "iPhone"
        "analyzer": "standard" // 标准分词器
      },
      "price": {
        "type": "float"        // 用float来存价格
      },
      "in_stock": {
        "type": "boolean"      // 是否有货
      },
      "release_date": {
        "type": "date",        // 日期类型，可以按时间排序、筛选
        "format": "yyyy-MM-dd" // 明确日期格式
      }
    }
  }
}

```

**1.2.8 Inverted Index:** 

专门为了**全文检索**而优化的数据结构

**结构概念**：词 → 出现这些词的文档列表

```json
apple" → [doc1, doc3, doc8]
"banana" → [doc2, doc5]
```

ES通过倒排索引可以极快地定位包含某个词的所有文档，而不是扫描所有文档。

**1.2.9 Doc Values:** 

为了支持排序、聚合（比如max、avg、sum等）而额外存储的一套数据结构

特点：列式存储，和倒排索引不同，Doc Values是面向列的

### 1.3 常见方法：

#### 索引管理

1.3.1 创建索引

```json
PUT /products 
```

1.3.2 查看索引信息

```json
GET /products 
```

1.3.3 修改索引设置

```json
DELETE /products 

PUT /products/_settings
{
  "number_of_replicas": 2
}
```

#### 文档操作（Document CRUD）

1.3.4 新增/覆盖一个文档

```json
PUT /products/_doc/1
{
  "name": "iPhone 15",
  "price": 7999,
  "in_stock": true
}
```

1.3.5 获取一个文档

```json
GET /products/_doc/1
```

1.3.6 部分更新一个文档

```json
POST /products/_update/1
{
  "doc": {
    "price": 7499
  }
}
```

1.3.7 删除一个文档

```json
DELETE /products/_update/1
```

#### 搜索查询（Search API）

1.3.8 简单全文搜索

```json
GET /products/_search
{
  "query": {               // 索引请求的核心部分，定义搜索的查询条件
    "match": {             // 全文匹配查询
      "name": "iPhone"     // 指定要搜索的字段为name，关键词是iPhone
    }
  }
}
```

1.3.9 精确匹配搜索

```json
GET /products/_search
{
  "query": {
    "term": {
      "in_stock": true
    }
  }
}
```

1.3.10 复合查询（bool查询）

```json
GET /products/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "name": "iPhone" }},
        { "range": { "price": { "lte": 8000 }}}
      ]
    }
  }
}
```

1.3.11 分页查询

```json
GET /products/_search
{
  "from": 0,
  "size": 10,
  "query": {
    "match_all": {}
  }
}
```

1.3.12 排序查询

```json
GET /products/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    { "price": "asc" }
  ]
}
```

#### 聚合分析（Aggregation）

1.3.13 统计某字段出现的频次（terms aggregation）

```json
GET /products/_search
{
  "size": 0,
  "aggs": {
    "department_count": {
      "terms": {
        "field": "department.keyword"
      }
    }
  }
}
```

1.3.14 计算数值型字段的最大、最小、平均值

```json
GET /products/_search
{
  "size": 0,
  "aggs": {
    "price_stats": {
      "stats": {
        "field": "price"
      }
    }
  }
}

```

1.3.15 时间序列分析（按天分组）

```json
GET /sales/_search
{
  "size": 0,
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "sale_date",
        "calendar_interval": "day"
      }
    }
  }
}

```

#### 批量操作（Bulk API）

1.3.16 一次性插入/更新/删除多条数据

```json
POST /_bulk
{ "index": { "_index": "products", "_id": "1" }}
{ "name": "iPhone 15", "price": 7999 }
{ "index": { "_index": "products", "_id": "2" }}
{ "name": "Galaxy S23", "price": 6999 }

```

#### 索引迁移（Reindex）

1.3.17

```json
POST /_reindex
{
  "source": {
    "index": "products"
  },
  "dest": {
    "index": "products_new"
  }
}

```

#### 索引管理端点

1.3.18 \_create

```json
PUT /my_index
```

1.3.19 \_delete

```json
DELETE /my_index 
```

1.3.20 \_open和\_close

```json
POST /my_index/_open
POST /my_index/_close
```

1.3.21 \_settings

```json
PUT /my_index/_settings 可更新索引设置
```

1.3.22 \_mapping

```json
PUT /my_index/_mapping 
```

#### 文档操作端点

#### 1.3.23 \_doc

```json
PUT /my_index/_doc/1     // 可创建或更新 ID 为 1 的文档。
GET /my_index/_doc/1     // 获取 ID 为 1 的文档。
DELETE /my_index/_doc/1  // 删除 ID 为 1 的文档。
```

#### 1.3.24 \_bulk

```json
PUT /my_index/_mapping 
```

#### 搜索端点

#### 1.3.23 \_search

```json
GET /my_index/_search  // 可在 my_index 索引中搜索文档
```

#### 1.3.23 \_count

```json
GET /my_index/_count // 可统计 my_index 索引中的文档总数
```

#### 聚合端点

1.3.24 \_search

```json
{
    "query": {
        "match_all": {}
    },
    "aggregations": {
        "category_count": {
            "terms": {
                "field": "category"
            }
        }
    }
}
```

#### 集群管理端点

1.3.25 \_cluster/health: 用于获取集群的健康状态信息、包含集群状态、节点数量

1.3.26 \_node: 用于获取集群中节点的信息，像节点名称、IP 地址、内存使用情况

#### 快照和恢复端点

1.3.27 \_snapshot

```json
PUT /_snapshot/my_backup_repository  // 创建名为 my_backup_repository 的快照仓库。
PUT /_snapshot/my_backup_repository/snapshot_1  //执行快照操作
```

1.3.28 \_restore

```json
POST /_snapshot/my_backup_repository/snapshot_1/_restore // 可从指定快照恢复数据。
```

### 1.4 使用场景：

# Foeye中如何实现支持用户下载API使用手册的

**API手册下载功能流程**
```
用户请求 → 权限验证 → 生成文档 → 文件打包 → 返回下载链接
```

# Foeye中如何实现设置黑白名单的功能

**黑白名单功能架构**
```
请求拦截 → IP检查 → 名单匹配 → 访问控制 → 记录日志
```

# Foeye中的消息队列Nats如何使用的

# Foeye中的设计模式详解

# Foeye中的ES如何使用的

# Foeye中的Redis如何使用的